{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC721.sol": {
      "content": "pragma solidity ^0.4.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes data\n    ) external;\n}\n"
    },
    "contracts/NFTSale.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.4.0;\n\nimport './interfaces/IERC721.sol';\nimport './Management.sol';\nimport './SafeMath.sol';\n\n/// @title A contract of the marketplace.\n/// @author Integral Team\ncontract NFTSale is Management {\n    using SafeMath for uint256;\n\n\n    /// @notice This event is fired when seller create the sell order\n    event OrderCreated(uint256 indexed orderIndex);\n\n    /// @notice This event is fired when seller fill the sell order\n    event OrderFilled(uint256 indexed orderIndex);\n\n    /// @notice This event is fired when seller reject the sell order\n    event OrderRejected(uint256 indexed orderIndex);\n\n    // This struct is describing the sell order information\n    struct SellOrder {\n        uint256 tokenId; // ID of the selling token\n        address seller; // seller address\n        uint256 price; // price of the selling token in ETH\n        Status status; // status of the sell order\n        uint256 expirationTime; // time when the sell order expires\n        uint256 paidFees; // amount of fees to pay\n    }\n\n    /// @notice the storage for the sell orders\n    mapping(uint256 => SellOrder) internal _sellOrders;\n\n    /// @notice This custom modifier is to validate if msg.sender is the seller of the sell orders\n    /// @param _at The index of the given sell roder in which seller is checked\n    modifier onlySellerOf(uint256 _at) {\n        require(_sellOrders[_at].seller == msg.sender, \"onlySeller\");\n        _;\n    }\n\n    constructor(\n        address _nftOnSale,\n        address _feeReceiver,\n        uint256 _minExpirationDuration,\n        uint256 _maxExpirationDuration,\n        uint256 _feeInBps\n    )\n        public\n        Management(\n          _nftOnSale,\n          _feeReceiver,\n          _minExpirationDuration,\n          _maxExpirationDuration,\n          _feeInBps\n        )\n    {}\n\n    /// @notice The standard getter to return an amount of the sell orders\n    /// @return Amount of the sell orders\n    function getSellOrdersAmount() external view returns(uint256) {\n        return _length;\n    }\n\n    /// @notice The standard getter to return a token ID of the given sell order\n    /// @param _at The index of the sell order\n    /// @return The ID of the selling token\n    function getSellOrderTokenId(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return _sellOrders[_at].tokenId;\n    }\n\n    /// @notice The standard getter to return a seller address of the given sell order\n    /// @param _at The index of the sell order\n    /// @return The seller address of the sell order\n    function getSellOrderSeller(uint256 _at) external view validIndex(_at) returns(address) {\n        return _sellOrders[_at].seller;\n    }\n\n    /// @notice The standard getter to return a price in ETH of the given sell order\n    /// @param _at The index of the sell order\n    /// @return Price in ETH\n    function getSellOrderPrice(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return _sellOrders[_at].price;\n    }\n\n    /// @notice The standard getter to return a fees to pay amount of the given sell order\n    /// @param _at The index of the sell order\n    /// @return Amount fees to pay\n    function getSellOrderFeesPaid(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return _sellOrders[_at].paidFees;\n    }\n\n    /// @notice The standard getter to return a status of the given sell order\n    /// @param _at The index of the auction\n    /// @return Status enumeration member as uint256\n    function getSellOrderStatus(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return uint256(_sellOrders[_at].status);\n    }\n\n    /// @notice The function cancel the sell order and return the token in the sell order to the seller.\n    /// @param _at The index of the sell order\n    function getBackFromSale(uint256 _at) external onlySellerOf(_at) {\n        nftOnSale.safeTransferFrom(address(this), msg.sender, _sellOrders[_at].tokenId);\n        if (block.timestamp <= _sellOrders[_at].expirationTime) {\n            _sellOrders[_at].status = Status.REJECTED;\n        } else {\n            _sellOrders[_at].status = Status.EXPIRED;\n        }\n        emit OrderRejected(_at);\n    }\n\n    /// @notice The function cancel the sell order and return the token in the sell order to the seller.\n    /// @param _nftToSell The token ID to sell through sell order\n    /// @param _price The price of the sell order\n    /// @param _expirationDuration The duration of the sell order, and when it passed the sell order could not be filled without restarting of the sell order.\n    function acceptTokenToSell(uint256 _nftToSell, uint256 _price, uint256 _expirationDuration)\n        external\n        validExpirationDuration(_expirationDuration)\n    {\n        nftOnSale.safeTransferFrom(msg.sender, address(this), _nftToSell);\n        _sellOrders[_length] = SellOrder({\n            tokenId: _nftToSell,\n            seller: msg.sender,\n            price: _price,\n            status: Status.PENDING,\n            expirationTime: block.timestamp.add(_expirationDuration),\n            paidFees: 0\n        });\n        emit OrderCreated(_length);\n        _length = _length.add(1);\n    }\n\n    /// @notice The function allows seller to change price.\n    /// @param _at The seller order index\n    /// @param _price The new price for the sell order\n    function setPriceFor(uint256 _at, uint256 _price) external\n        validIndex(_at)\n        onlySellerOf(_at)\n    {\n        _sellOrders[_at].price = _price;\n    }\n\n    /// @notice The function allows seller continue selling by expanding the expiration time of the sell order.\n    /// @param _at The seller order index\n    /// @param _expirationTime The new expiration time for the sell order\n    function setExpirationTimeFor(uint256 _at, uint256 _expirationTime) external\n        validIndex(_at)\n        onlySellerOf(_at)\n    {\n        require(_sellOrders[_at].expirationTime <= _expirationTime, \"onlyFutureTimeAllowed\");\n        _sellOrders[_at].expirationTime = _expirationTime;\n    }\n\n    /// @notice The function allows anyone to fill sell order.\n    /// @param _at The seller order index\n    function buy(uint256 _at) external payable nonReentrant validIndex(_at) {\n        uint256 price = _sellOrders[_at].price;\n        uint256 feeAmount = price.mul(feeInBps).div(MAX_FEE);\n        require(msg.value >= price.add(feeAmount), \"notEnoughFunds\");\n        require(_sellOrders[_at].status == Status.PENDING, \"orderIsFilledOrRejected\");\n        require(block.timestamp <= _sellOrders[_at].expirationTime, \"orderIsExpired\");\n\n        nftOnSale.safeTransferFrom(address(this), msg.sender, _sellOrders[_at].tokenId);\n        _sellOrders[_at].seller.transfer(_sellOrders[_at].price);\n        feeReceiver.transfer(feeAmount);\n        _sellOrders[_at].paidFees = feeAmount;\n        _sellOrders[_at].status = Status.FILLED;\n        emit OrderFilled(_at);\n    }\n}\n"
    },
    "contracts/Management.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.4.0;\n\nimport './Ownable.sol';\nimport './ReentrancyGuard.sol';\nimport './interfaces/IERC721.sol';\n\n/// @title A contract for holding management functions and modifiers.\n/// @author Integral Team\ncontract Management is Ownable, ReentrancyGuard {\n\n    // This enumeration is describing different statuses of the different orders\n    enum Status {\n        PENDING,\n        FILLED,\n        REJECTED,\n        EXPIRED\n    }\n\n    /// @notice This is max of the basis points\n    uint256 public constant MAX_FEE = 10000;\n\n    /// @notice This is a fee amount in basis points using in sell orders and auctions\n    uint256 public feeInBps;\n\n    /// @notice This is the address which will receive any kind of fees (either in marketplace or auction)\n    address public feeReceiver;\n\n    /// @notice This is the lower border of the expiration duration that used in orders of marketplace and in auctions\n    uint256 public minExpirationDuration;\n\n    /// @notice This is the upper border of the expiration duration that used in orders of marketplace and in auctions\n    uint256 public maxExpirationDuration;\n\n    /// @notice This is the amount of either sell orders or auctions\n    uint256 internal _length;\n\n    /// @notice This is a NFT which could be sold in marketplace or auction\n    IERC721 public nftOnSale;\n\n    /// @notice This is a standard constructor with one argument\n    /// @param _nftOnSale The NFT which could be sold in marketplace or auction\n    constructor(\n        address _nftOnSale,\n        address _feeReceiver,\n        uint256 _minExpirationDuration,\n        uint256 _maxExpirationDuration,\n        uint256 _feeInBps\n    ) public {\n        nftOnSale = IERC721(_nftOnSale);\n        feeReceiver = _feeReceiver;\n        minExpirationDuration = _minExpirationDuration;\n        maxExpirationDuration = _maxExpirationDuration;\n        feeInBps = _feeInBps;\n    }\n\n    /// @notice This custom modifier is to validate index of either sell order or auction\n    /// @param _at An index in the mapping of auctions or sell orders\n    modifier validIndex(uint256 _at) {\n        require(_at < _length, \"invalidIndex\");\n        _;\n    }\n\n    /// @notice This custom modifier is to validate expiration duration of either sell order or auction\n    /// @param _expirationDuration The duration which about to be used in auction or sell order\n    modifier validExpirationDuration(uint256 _expirationDuration) {\n        require(_expirationDuration >= minExpirationDuration && _expirationDuration <= maxExpirationDuration, \"invalidExpirationDuration\");\n        _;\n    }\n\n    /// @notice A standard setter for the working NFT which available only for user\n    /// @param _newNFTOnSale The new NFT token address\n    function setWorkingNFT(address _newNFTOnSale) external onlyOwner {\n        nftOnSale = IERC721(_newNFTOnSale);\n    }\n\n    /// @notice A standard setter for the fee receiver address which available only for user\n    /// @param _feeReceiver The new fee receiver address\n    function setFeeReceiver(address _feeReceiver) external onlyOwner {\n        feeReceiver = _feeReceiver;\n    }\n\n    /// @notice A standard setter for the fee BPS amount which available only for user\n    /// @param _fee The new amount of fee in BPS\n    function setFee(uint256 _fee) external onlyOwner {\n        feeInBps = _fee;\n    }\n\n    /// @notice A standard setter for the minimum expiration duration which available only for user\n    /// @param _minExpirationDuration The new minimum expiration duration in seconds\n    function setMinExpirationDuration(uint256 _minExpirationDuration) external onlyOwner {\n        minExpirationDuration = _minExpirationDuration;\n    }\n\n    /// @notice A standard setter for the maximum expiration duration which available only for user\n    /// @param _maxExpirationDuration The new maximum expiration duration in seconds\n    function setMaxExpirationDuration(uint256 _maxExpirationDuration) external onlyOwner {\n        maxExpirationDuration = _maxExpirationDuration;\n    }\n\n    /// @notice Default fallback function which allows the contract to accept ether\n    function() external payable {}\n}\n"
    },
    "contracts/SafeMath.sol": {
      "content": "pragma solidity ^0.4.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "contracts/Ownable.sol": {
      "content": "pragma solidity ^0.4.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() public {\n        _transferOwnership(msg.sender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.4.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() public {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/NFTAuction.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.4.0;\n\nimport './interfaces/IERC721.sol';\nimport './Management.sol';\nimport './SafeMath.sol';\n\n/// @title A contract for auctioning the NFTs.\n/// @author Integral Team\ncontract NFTAuction is Management {\n    using SafeMath for uint256;\n\n    // This struct is describing the auction information\n    struct Auction {\n        uint256 tokenId; // id of the auctioning token\n        address seller; // id of the seller who is selling the auctioning token\n        address lastBuyer; // the last of the buyers who bid last and faster than anyone\n        uint256 stopTime; // the time after which the auction is considered closed and \"take\" function is unblocked\n        uint256 currentPrice; // the current price of the auctioning timer, it do rise as auction proceed\n        uint256 feesToPay; // the fees amount which must be payed above the current price\n        Status status; // the status of the auction\n    }\n\n    /// @notice This event is fired when seller create an auction\n    event AuctionCreated(uint256 indexed _at);\n\n    /// @notice This event is fired when seller reject the auction\n    event AuctionRejected(uint256 indexed _at);\n\n    /// @notice This event is fired when last buyer buy the auctioning item after auction is done\n    event AuctionFilled(uint256 indexed _at);\n\n    /// @notice This event is fired when some buyer bids on the auction\n    event AuctionBid(uint256 indexed _at);\n\n    /// @notice This mapping contains the auctions history\n    mapping(uint256 => Auction) internal _auctions;\n\n    /// @notice This custom modifier is to validate if msg.sender is the seller of the auction\n    /// @param _at The index of the given auction in which seller is checked\n    modifier onlySellerOf(uint256 _at) {\n        require(_auctions[_at].seller == msg.sender, \"onlySeller\");\n        _;\n    }\n\n    constructor(\n        address _nftOnSale,\n        address _feeReceiver,\n        uint256 _minExpirationDuration,\n        uint256 _maxExpirationDuration,\n        uint256 _feeInBps\n    )\n        public\n        Management(\n          _nftOnSale,\n          _feeReceiver,\n          _minExpirationDuration,\n          _maxExpirationDuration,\n          _feeInBps\n        )\n    {}\n\n    /// @notice The standard getter to return an amount of the auctions\n    /// @return Amount of the auctions\n    function getAuctionsAmount() external view returns(uint256) {\n        return _length;\n    }\n\n    /// @notice The standard getter to return a token ID of the given auctions selling token\n    /// @param _at The index of the auction\n    /// @return The ID of the auctions selling token\n    function getTokenIdOfAuction(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return _auctions[_at].tokenId;\n    }\n\n    /// @notice The standard getter to return a seller of the given auction\n    /// @param _at The index of the auction\n    /// @return Seller address\n    function getSellerOfAuction(uint256 _at) external view validIndex(_at) returns(address) {\n        return _auctions[_at].seller;\n    }\n\n    /// @notice The standard getter to return a seller of the given auction\n    /// @param _at The index of the auction\n    /// @return Seller address\n    function getLastBuyerOfAuction(uint256 _at) external view validIndex(_at) returns(address) {\n        return _auctions[_at].lastBuyer;\n    }\n\n    /// @notice The standard getter to return a stop time of the given auction\n    /// @param _at The index of the auction\n    /// @return Stop time in UNIX timestamp\n    function getStopTimeOfAuction(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return _auctions[_at].stopTime;\n    }\n\n    /// @notice The standard getter to return a current price of the given auction\n    /// @param _at The index of the auction\n    /// @return Current price of the auctioning token\n    function getCurrentPriceOfAuction(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return _auctions[_at].currentPrice;\n    }\n\n    /// @notice The standard getter to return a current amount of fees to pay of the given auction\n    /// @param _at The index of the auction\n    /// @return Current amount of fees to pay\n    function getCurrentFeesToPayOfAuction(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return _auctions[_at].feesToPay;\n    }\n\n    /// @notice The standard getter to return a status of the given auction\n    /// @param _at The index of the auction\n    /// @return Status enumeration member as uint256\n    function getStatusOfAuction(uint256 _at) external view validIndex(_at) returns(uint256) {\n        return uint256(_auctions[_at].status);\n    }\n\n    /// @notice The function which could create a auction\n    /// @param _nftToSell The selling token ID\n    /// @param _expirationDuration Duration of the auction in valid bounds (between min and max value of the duration)\n    /// @param _startPrice Starting price of the selling token in ETH (wei)\n    function createAuction(uint256 _nftToSell, uint256 _expirationDuration, uint256 _startPrice)\n        external\n        validExpirationDuration(_expirationDuration)\n    {\n        nftOnSale.safeTransferFrom(msg.sender, address(this), _nftToSell);\n        _auctions[_length] = Auction({\n            tokenId: _nftToSell,\n            seller: msg.sender,\n            lastBuyer: address(0),\n            stopTime: block.timestamp.add(_expirationDuration),\n            currentPrice: _startPrice,\n            feesToPay: 0,\n            status: Status.PENDING\n        });\n        emit AuctionCreated(_length);\n        _length = _length.add(1);\n    }\n\n    /// @notice This function can be called only by the seller of the auctioning item\n    /// and provides the functional to reject or expire the auction if certain amount of time passed.\n    /// Emits the AuctionRejected event\n    /// @param _at The index of the auction\n    function cancelAuction(uint256 _at)\n        external\n        validIndex(_at)\n        onlySellerOf(_at)\n    {\n        require(_auctions[_at].status == Status.PENDING, \"auctionIsEitherFilledOrRejectedOrExpired\");\n        nftOnSale.safeTransferFrom(address(this), msg.sender, _auctions[_at].tokenId);\n        if (block.timestamp <= _auctions[_at].stopTime) {\n          _auctions[_at].status = Status.REJECTED;\n        } else {\n          _auctions[_at].status = Status.EXPIRED;\n        }\n        emit AuctionRejected(_at);\n    }\n\n    /// @notice Allows anyone to bid in the ceriatin auction if they have needed balance.\n    /// @param _at The index of the auction\n    /// @param _newPrice The price which the buyer want to spend at the auctioning item.\n    /// Must be greater than current price in the auction.\n    function bid(uint256 _at, uint256 _newPrice) external validIndex(_at) {\n        require(msg.sender.balance >= _newPrice, \"notEnoughFundsToProveYourBid\");\n        require(_auctions[_at].currentPrice < _newPrice, \"cannotBidOnLowerPrice\");\n        require(block.timestamp <= _auctions[_at].stopTime, \"auctionIsStopped\");\n        require(_auctions[_at].status == Status.PENDING, \"auctionMustBePending\");\n        _auctions[_at].currentPrice = _newPrice;\n        _auctions[_at].lastBuyer = msg.sender;\n        _auctions[_at].feesToPay = _newPrice.mul(feeInBps).div(MAX_FEE);\n        emit AuctionBid(_at);\n    }\n\n    /// @notice Allows the address who won the auction pay and take bought NFT item.\n    /// @param _at The index of the auction\n    function take(uint256 _at) external payable nonReentrant {\n        require(msg.value >= _auctions[_at].currentPrice.add(_auctions[_at].feesToPay), \"notEnoughFunds\");\n        require(block.timestamp > _auctions[_at].stopTime, \"auctionIsStopped\");\n        require(msg.sender == _auctions[_at].lastBuyer, \"senderMustBeBuyerWhoWon\");\n        _auctions[_at].seller.transfer(_auctions[_at].currentPrice);\n        feeReceiver.transfer(_auctions[_at].feesToPay);\n        nftOnSale.safeTransferFrom(address(this), _auctions[_at].lastBuyer, _auctions[_at].tokenId);\n        _auctions[_at].status = Status.FILLED;\n        emit AuctionFilled(_at);\n    }\n\n}\n"
    },
    "contracts/mocks/MockNFT.sol": {
      "content": "pragma solidity ^0.4.0;\n\nimport \"../interfaces/IERC721.sol\";\n\ncontract MockNFT is IERC721 {\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    function balanceOf(address owner) external view returns(uint256 balance) {\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) external view returns(address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        __safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function __safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes data\n    ) internal {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes data\n    ) external {\n      __safeTransferFrom(from, to, tokenId, data);\n    }\n\n    function approve(address to, uint256 tokenId) external {\n        address owner = IERC721(address(this)).ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            msg.sender == owner || _operatorApprovals[owner][msg.sender],\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) external view returns(address operator) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool _approved) external {\n        _setApprovalForAll(msg.sender, operator, _approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) external view returns(bool) {\n         return _operatorApprovals[owner][operator];\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal {\n        _transfer(from, to, tokenId);\n    }\n\n    function _exists(uint256 tokenId) internal view  returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view  returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = IERC721(address(this)).ownerOf(tokenId);\n        return (spender == owner || _tokenApprovals[tokenId] == spender || _operatorApprovals[owner][spender]);\n    }\n\n    function _mint(address to, uint256 tokenId) internal  {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal  {\n        require(IERC721(address(this)).ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal  {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _approve(address to, uint256 tokenId) internal {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(IERC721(address(this)).ownerOf(tokenId), to, tokenId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal  {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}